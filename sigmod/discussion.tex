
\section{Other Frameworks}
\label{sec:other-orms}

While our focus in this paper is on Rails, we briefly investigated the
incidence of (problematic, in Rails) uniqueness and foreign key
constraints in several other frameworks.

\newcommand{\orm}[1]{{\vspace{.45em}\noindent\textit{#1}}}

\orm{Java Persistence API}
(JPA; version EE 7)\footnote{\url{http://docs.oracle.com/javaee/7/api/javax/persistence/package-summary.html}}
is a standard Java Object persistence interface and supports both
uniqueness and primary key constraints in the database via specialized
object annotations. Thus, when JPA is used to create a table, it will
use the database to enforce these constraints. In 2009, JPA introduced
support for UDF validations via a JavaBean interface.\footnote{Most
  recent update: \url{https://jcp.org/en/jsr/detail?id=349}} Interestingly,
the Bean validation proposal specifically addresses the use of
uniqueness validations:
\begin{quote}
``Question: should we add @Unique that would map to @Column(unique=true)?
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part
of the [Bean Validation] spec today.''~\cite{jsr-bean}
\end{quote}
An author of some of the code specification notes on a separate blog
post:
\begin{quote}
  ``The reason @Unique is not part of the built-in constraints is the
  fact that accessing the Session/EntityManager during a valiation
  [sic] is opening yourself up for potenital phantom reads. Think
  twice before you go for [a UDF-based] approach.''~\cite{unique-bean}
\end{quote}
%http://download.oracle.com/otn-pub/jcp/persistence-2.0-fr-eval-oth-JSpec/persistence-2_0-final-spec.pdf?AuthParam=1414639627_4654729130380ec6809634192c3faacb
By default, JPA Validations are triggered pre-commit upon model
change and therefore run in a transaction.

\orm{Hibernate} (version 4.3.5), a Java ORM based on JPA, does
not automatically back declared relationships. For uniqueness and
foreign key constraints, it relies on JPA annotations for
correctness. However, it also has an extensive user-level validation
framework.\footnote{\url{http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html/}}

\orm{CakePHP} (version 2.5.5), a PHP-based web
framework,\footnote{\url{http://cakephp.org/}} supports uniqueness,
foreign key, and UDF validations via user-level checks. It does not
back any of its validation checking with a database transaction and
relies on the user to correctly specify the schema.

\orm{Django} (version 1.7), a popular Python-based
framework,\footnote{\url{https://www.djangoproject.com/}} backs declared
uniqueness and foreign key constraints with database-level
invariants. It also supports custom validations.

\orm{Laravel} (version 4.2), another PHP-based web framework,\footnote{\url{http://laravel.com/}} supports the same
set of functionality as CakePHP. Any database-backed constraints must
be specified manually in the schema. The authors note that
``database-level validations can efficiently handle some things (such
as uniqueness of a column in heavily-used tables) that can be
difficult to implement otherwise...The other big downside to this
approach is that your validations would be database- and
schema-specific, which makes migrations or switching to another
database backend more difficult in the future.''

\orm{Waterline} (version 0.10), a persistence layer for
node.js\footnote{\url{https://github.com/balderdashy/waterline}} (backing
Sails.js, a popular MVC
framework\footnote{\url{https://github.com/balderdashy/sails}}),
provides support for in-DB foreign key and uniqueness constraints
where supported. We found several reports of bugs in early support of
uniqueness
constraints\footnote{\url{https://github.com/balderdashy/sails-mongo/issues/152}
  \url{https://github.com/balderdashy/waterline/issues/55}
  \url{https://github.com/balderdashy/waterline/issues/236}}.

\minihead{Summary} The use of validations appears to be common
practice; the inclusion of validations in (and associated review
processes associated with) a mature, Enterprise-grade programming
environment as Java EE suggests that, in fact, users appreciate
domain-specific validation. The care with which validations are
applied, however, is domain-dependent. While the Java EE developers
appear familiar with database anomalies, as we have seen, their more
lackadaisical Rails implementation can cause serious issues. While
frameworks such as Django indeed follow suit, enforcing constraints in
the database as appropriate, it is surprising to see both PHP-based
frameworks rely on the user to declare in-database constraints
\textit{while still} supporting totally feral application-level
constraints. This again suggests an enforcement strategy similar to
that of Rails. However, while Rails automatically generates schemas,
the onus in these frameworks is potentially greater on the end-user as
she is responsible for ultimately declaring schema migrations.


\begin{comment}

Name & PK & FK & UDF Validations
DJANGO & Automatic & Automatic & Yes
JPA & Yes, annotation & Yes, annotation & Yes, via Beans
CakePHP & 

% Django

Supports validations
https://docs.djangoproject.com/en/dev/ref/validators/

Broken online: http://stackoverflow.com/a/5690705


1.9 (not yet released) deprecating in favor of checks
https://docs.djangoproject.com/en/1.7/internals/deprecation/

checks:
https://docs.djangoproject.com/en/1.7/topics/checks/



%FK 

does it right
https://docs.djangoproject.com/en/1.7/ref/models/fields/#django.db.models.ForeignKey

%PK

does it right, by default declares an index
https://docs.djangoproject.com/en/1.7/_modules/django/db/backends/schema/


'''
If True, this field must be unique throughout the table.

This is enforced at the database level and by model validation. If you try to save a model with a duplicate value in a unique field, a django.db.IntegrityError will be raised by the model’s save() method.

This option is valid on all field types except ManyToManyField, OneToOneField, and FileField.

Note that when unique is True, you don’t need to specify db_index, because unique implies the creation of an index.
'''
a

% Hibernate/JPA


%FK 

no FK by default, relies on JPA
http://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html/ch08.html

JoinColumn
http://docs.oracle.com/javaee/6/api/javax/persistence/OneToMany.html

%PK

``The reason @Unique is not part of the built-in constraints is the fact that accessing the Session/EntityManager during a valiation is opening yourself up for potenital phantom reads. Think twice before you go for the following approach.''
https://developer.jboss.org/wiki/AccessingtheHibernateSessionwithinaConstraintValidator?_sscc=t
http://stackoverflow.com/questions/17092601/validate-unique-username-in-spring

http://docs.oracle.com/javaee/6/api/javax/persistence/UniqueConstraint.html

BEAN supported
https://jcp.org/en/jsr/detail?id=303

%CakePHP
supports udf validations
http://book.cakephp.org/2.0/en/models/data-validation.html

basically you set up your own schema, but default validations don't
appear to be transactional

%FK 


%PK

https://github.com/cakephp/cakephp/blob/50b3893e6507979427e1aaeb435494aed1af4f52/lib/Cake/Model/Model.php#L3303


% Laravel

Manually define database schema!

%FK 
%PK

http://laravel.com/docs/4.2/validation#rule-unique
https://github.com/laravel/framework/blob/75b1dff27778354e44511556171cf6ae466c8b59/src/Illuminate/Validation/Validator.php#L940


http://laravelbook.com/laravel-input-validation/

% Node -- Sail.js
%FK 
%PK

Validations are handled by Anchor, a thin layer on top of Validator, one of the most robust validation libraries for Node.js. Sails supports most of the validations available in Validator, as well as a few extras that require database integration, like unique.

http://sailsjs.org/#/documentation/concepts/ORM/Validations.html
https://github.com/balderdashy/sails/issues/832

https://github.com/balderdashy/waterline

Broken in Mongo
https://github.com/balderdashy/sails-mongo/issues/152

Broken in dev
https://github.com/balderdashy/waterline/issues/55

Because you have migrate: safe set the indexes will not be created when you start the ORM.
https://github.com/balderdashy/waterline/issues/236

uses db foreign keys

\end{comment}


% what can we learn?
% udfs


\section{Design Revisited}
\label{sec:discussion}

In this section, we discuss the implications of this study's results
for future database systems designs and research.

\subsection{Feral Invariants}

In Rails and, across the other ORMs we studied, the use of
application-enforced invariants was surprisingly common. Notably, the
inclusion of validations in the Java EE JPA specification (including
effort from with 41 representatives from companies including Google,
Oracle, and Red Hat), suggests that validations are, in fact, a common
way to express domain logic.

The second part of our study here hints at the \textit{challenges}
inherent in actually providing correct invariant-based concurrency
control. Despite the fact that ORMs such as Rails and JPA wrap
validations within the scope of a transaction, the pervasive use of
weak isolation thwarts the benefit of non-I-confluent
validations. (When default database isolation is non-serializable,
expect ``convention over configuration'' to lead to isolation
anomalies.) A small but notable portion of these validations cannot be
sufficiently enforced under non-serializable isolation. Moreover,
there is compelling evidence that the framework authors \textit{are}
aware of this issue (e.g., Footnote~\ref{fn:si-rails}, the JPA
comments in Section~\ref{sec:other-orms}). While serializable
isolation is conceptually sufficient to correctly enforce isolation,
its lack of support in databases such as Oracle 12c and implementation
bugs such as the error we encountered in PostgreSQL are often enough
to compromise validator integrity. The complete divorce of validation
annotations from schema declaration in both PHP frameworks we examined
is even more perplexing. These trends hint at, on the one hand, a
desire for greater flexibility, and, on the other hand, a disregard of
database safety mechanisms such as built-in uniqueness and referential
integrity constraints.

We see considerable opportunity in bridging this gap and better
facilitating these application-level validations. Doing so has not
only correctness implications but also performance implications: in a
tiered application deployment, native integration of user-defined
validations with the database can help eliminate database
RTTs~\cite{pyxis}---which, in particular, can assist with reducing the
duration for which locks are held. While the best of these validation
implementations rely on transactions for isolation, we see opportunity
for invariant- or validation-based concurrency control, thus allowing
higher concurrency and avoiding the cost of serializable isolation
that these data stores and users have evidently eschewed. This hints
at the possibility of a revival of concepts from active and rule-based
databases~\cite{activedb-book} and, broadly, semantic concurrency
control. The challenge of declaring semantic criteria for correctness
is already being performed by database users---at least for some
correctness criteria. It remains to be seen whether, in fact, these
validations can be treated as a complete specification for
correctness. Nevertheless, we see the fact that they are being used
organically and have been produced by database users (in lieu of
standard transaction model) as ample cause for re-evaluating the
decades of work on semantic concurrenty control.

\subsection{Usability and ``Correctness''}

Returning, finally, to the Rails central goal of programmer
productivity, our results ultimately hint at a triumph of convenience
over formal---and, in some cases, practical---correctness
guarantees. Nevertheless, we have observed that the ``convenient''
feral validations actually do serve a purpose in reducing worst-case
data integrity errors. In a sense, this suggests that, in fact, these
validations are somehow sufficient for most applications, or,
alternatively, other errors loom larger for developers.

The takeaway for the database community here is, in a sense, somewhat
sobering. Ultimately, under the hypothesis that Rails has succeeded
due to its usability and productivity, conventional databases have
largely failed to provide the same end-user efficiency. As we noted in
Section~\ref{sec:intro}, this echoes many strains of the NoSQL
movement; per Basho's Justin Sheehy: ``What does a first-time user of
your system experience in their first five
minutes?''~\cite{marcus-talk} Rails simplifies this process and makes
the process of getting started remarkably straightforward, with a
plethora of documentation online. Proper database configuration is
less so, and understanding, for example, the slew of anomalies that
characterize each isolation level (which also vary between stores),
remains a subject of graduate-level study within
databases~\cite{adya-isolation,hat-vldb}. Moreover, a first-time user
is unlikely to run a highly concurrent workload and experience such
integrity violations; rather, it is only at scale that they might
encounter them.

The opportunity here is to develop database systems that provide
usability at both the early stages and, subsequently, at later
stages. We are by no means the first to make this
observation. However, in the context of modern web frameworks, it is
our perogative to better support these users who, otherwise, appear
content to ignore much of the technological advances within the
database community of the last four decades.


% Use of weak isolation

 % Pivotal moment: ignore these use cases, or better support them?
 % Java EE!?!?
 % To do so, active database systems?
 % Drop into serializable transactions is a non-starter

 % Do not claim completeness, but nevertheless striking trends
 % Productivity-oriented programming and usability