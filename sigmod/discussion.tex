
\section{Other Frameworks}
\label{sec:other-orms}

While our focus in this paper is on Rails, we briefly investigated
support for uniqueness, foreign key, and custom validations in several
other frameworks. We find widespread support for these constructs in
addition to varying degrees of susceptibility to integrity errors.

\newcommand{\orm}[1]{{\vspace{.45em}\noindent\textit{#1}}}

\orm{Java Persistence API} (JPA; version EE 7)~\cite{code-jpa} is a
standard Java Object persistence interface and supports both
uniqueness and primary key constraints in the database via specialized
object annotations. Thus, when JPA is used to create a table, it will
use the database to enforce these constraints. In 2009, JPA introduced
support for UDF validations via a JavaBean
interface~\cite{code-bean-validation}. Interestingly, both the
original (and current) Bean validation specifications specifically
address the use of uniqueness validations in their notes:
\begin{quote}
``Question: should we add @Unique that would map to @Column(unique=true)?
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part
of the [Bean Validation] spec today.''~\cite{jsr-bean}
\end{quote}
An author of a portion of the code specification notes separately:
\begin{quote}
  ``The reason @Unique is not part of the built-in constraints is the
  fact that accessing the [database] during a valiation [sic] is
  opening yourself up for potenital [sic] phantom reads. Think twice
  before you go for [an application-level] approach.''~\cite{unique-bean}
\end{quote}
%http://download.oracle.com/otn-pub/jcp/persistence-2.0-fr-eval-oth-JSpec/persistence-2_0-final-spec.pdf?AuthParam=1414639627_4654729130380ec6809634192c3faacb
By default, JPA Validations are run upon model save and run in a
transaction at the default isolation level, and therefore, as the
developers above hint, are susceptible to the same kinds of integrity
violations we study here.

\orm{Hibernate} (version 4.3.7)~\cite{code-hibernate}, a Java ORM
based on JPA, does \textit{not} automatically enforce declared foreign
key relationships: if a foreign key constraint is declared; a
corresponding column is added, but that column is \textit{not} backed by a
database foreign key. Instead, for both uniqueness and foreign key
constraints, Hibernate relies on JPA schema annotations for
correctness. Therefore, without appropriate schema annotations,
Hibernate's basic associations may contain dangling references. Hibernate also has an extensive user-level validation
framework implementing on the JPA Validation Bean
specification~\cite{code-hibernate-validator} and is sensitive to weak
isolation anomalies, similar to Rails validations.

\orm{CakePHP} (version 2.5.5)~\cite{code-cakephp}, a PHP-based web
framework, supports uniqueness, foreign key, and UDF
validations. CakePHP does \textit{not} back any of its validation
checking with a database transaction and relies on the user to
correctly specify any corresponding foreign keys or uniqueness
constraints within the database the schema. Thus, while users can
declare each of these validations, there is no guarantee that they are
actually enforced by the database. Thus, unless users are careful to
specify constraints in both their schema and in their validations,
validations may lead to integrity violations.

\orm{Laravel} (version 4.2)~\cite{code-laravel}, another PHP-based web
framework, supports the same set of functionality as CakePHP. Laravel
supports uniqueness, foreign key, and UDF validations in the
application, but any database-backed constraints must be specified
manually in the schema. Per one set of community documentation~\cite{laravel-book}, ``database-level
validations can efficiently handle some things (such as uniqueness of
a column in heavily-used tables) that can be difficult to implement
otherwise'' but ``[t]esting and maintenance is more difficult...[and]
your validations would be database- and schema-specific, which makes
migrations or switching to another database backend more difficult in
the future.'' In contrast, model-level validations are ``the
recommended way to ensure that only valid data is saved into your
database. They are database agnostic, cannot be bypassed by end users,
and are convenient to test and maintain.'' There
is no mention of concurrency in this current treatment, despite the
glaring potential for integrity errors.

\orm{Django} (version 1.7)~\cite{code-django}, a popular Python-based
framework, backs declared uniqueness and foreign key constraints with
database-level constraints. It also supports custom validations, but
these validations are not wrapped in a
transaction~\cite{code-django-constraints}. Thus, Django also appears
problematic, but only for custom validations.

\orm{Waterline} (version 0.10), a persistence layer for
node.js~\cite{code-waterline} (backing Sails.js, a popular MVC
framework written in Node.js~\cite{code-sails}), provides support for
in-DB foreign key and uniqueness constraints (when supported by the
database) as well as custom validations (that are \textit{not}
supported via transactions; e.g., ``TO-DO: This should all be wrapped
in a transaction. That's coming next but for the meantime just hope we
don't get in a nasty state where the operation
fails!''~\cite{code-waterline-txn}).

% Implementing and using unique indexes~\cite{waterline-unique-one,waterline-unique-two}.

\begin{comment}

Name & PK & FK & UDF Validations
DJANGO & Automatic & Automatic & Yes
JPA & Yes, annotation & Yes, annotation & Yes, via Beans
CakePHP & 

% Django

Supports validations
https://docs.djangoproject.com/en/dev/ref/validators/

Broken online: http://stackoverflow.com/a/5690705


1.9 (not yet released) deprecating in favor of checks
https://docs.djangoproject.com/en/1.7/internals/deprecation/

checks:
https://docs.djangoproject.com/en/1.7/topics/checks/



%FK 

does it right
https://docs.djangoproject.com/en/1.7/ref/models/fields/#django.db.models.ForeignKey

%PK

does it right, by default declares an index
https://docs.djangoproject.com/en/1.7/_modules/django/db/backends/schema/


'''
If True, this field must be unique throughout the table.

This is enforced at the database level and by model validation. If you try to save a model with a duplicate value in a unique field, a django.db.IntegrityError will be raised by the model’s save() method.

This option is valid on all field types except ManyToManyField, OneToOneField, and FileField.

Note that when unique is True, you don’t need to specify db_index, because unique implies the creation of an index.
'''
a

% Hibernate/JPA


%FK 

no FK by default, relies on JPA
http://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html/ch08.html

JoinColumn
http://docs.oracle.com/javaee/6/api/javax/persistence/OneToMany.html

%PK

``The reason @Unique is not part of the built-in constraints is the fact that accessing the Session/EntityManager during a valiation is opening yourself up for potenital phantom reads. Think twice before you go for the following approach.''
https://developer.jboss.org/wiki/AccessingtheHibernateSessionwithinaConstraintValidator?_sscc=t
http://stackoverflow.com/questions/17092601/validate-unique-username-in-spring

http://docs.oracle.com/javaee/6/api/javax/persistence/UniqueConstraint.html

BEAN supported
https://jcp.org/en/jsr/detail?id=303

%CakePHP
supports udf validations
http://book.cakephp.org/2.0/en/models/data-validation.html

basically you set up your own schema, but default validations don't
appear to be transactional

%FK 


%PK

https://github.com/cakephp/cakephp/blob/50b3893e6507979427e1aaeb435494aed1af4f52/lib/Cake/Model/Model.php#L3303


% Laravel

Manually define database schema!

%FK 
%PK

http://laravel.com/docs/4.2/validation#rule-unique
https://github.com/laravel/framework/blob/75b1dff27778354e44511556171cf6ae466c8b59/src/Illuminate/Validation/Validator.php#L940


http://laravelbook.com/laravel-input-validation/

% Node -- Sail.js
%FK 
%PK

Validations are handled by Anchor, a thin layer on top of Validator, one of the most robust validation libraries for Node.js. Sails supports most of the validations available in Validator, as well as a few extras that require database integration, like unique.

http://sailsjs.org/#/documentation/concepts/ORM/Validations.html
https://github.com/balderdashy/sails/issues/832

https://github.com/balderdashy/waterline

Broken in Mongo
https://github.com/balderdashy/sails-mongo/issues/152

Broken in dev
https://github.com/balderdashy/waterline/issues/55

Because you have migrate: safe set the indexes will not be created when you start the ORM.
https://github.com/balderdashy/waterline/issues/236

uses db foreign keys

\end{comment}

% what can we learn?
% udfs


\section{Implications for Databases}
\label{sec:discussion}

In this section, we discuss the implications of this study's results
for future database systems designs and research.

In Rails and, across the other ORMs we studied, the use of
application-enforced invariants was surprisingly common. The
inclusion of validations in a framework as mature as the Java EE JPA
specification (which was produced by a group of 41 representatives
from companies including Google, Oracle, and Red Hat), suggests that
invariants are, in fact, a common way to express domain logic in web
frameworks (and are not simply an artifact of Rails). We therefore
believe that appropriate enforcement of these invariants should be an
important concern for database management systems.

Among the frameworks we have studied, we can identify three main
approaches to invariant enforcement:
\begin{defendenumerate}
\item Let the application enforce the invariants, and also let
  the application prevent concurrency anomalies.

\item Let the application enforce the invariants, and use database
  transactions to mediate between concurrent invariant checks and updates.

\item Let the database perform invarian checking (e.g., by declaring a
  unique index on a column that is supposed to be unique).
\end{defendenumerate}

The first approach effectively punts the problems of concurrency
control to the application writer---an error-prone and often onerous
process that we do not believe is a constructive avenue for future
applications. However, the second and third options have merit and practical
consequences, which we explore here.

\subsection{Supporting Invariants via Transactions}

Conceptually, serializable
isolation is sufficient to correctly enforce invariants when
application-level checking is wrapped within a transaction (as in
Rails). In practice, the rampant (frequently default, sometimes
unavoidable) use of weak isolation~\cite{hat-vldb} undermines the
effectiveness of this approach and, more broadly, the success of the
transaction concept. As this paper has demonstrated, enforcing invariants via
non-serializable transactions can lead to a variety of integrity
violations. While developers associate DBMSs with ``ACID'' and
serializability, they are not getting either.

In principle, we might simply mandate all programmers to use
serializable transactions. In practice, lack of support for
serializable isolation in databases such as Oracle 12c and
implementation bugs such as the error we discovered in PostgreSQL
raise complex challenges pertaining to portability and
reliability. Moreover, translating invariants into transactional reads and writes
can be remarkably inefficient (e.g., compare the cost of performing a
predicate-based lookup, lock acquisition, and insertion versus
enforcing a database-backed uniqueness constraint upon write).

There is compelling evidence that some framework authors \textit{are}
aware of this issue (e.g., Footnote~\ref{fn:si-rails}, the JPA
comments in Section~\ref{sec:other-orms}). However, despite this
awareness, these frameworks \textit{still} allow integrity violations
and have not take steps to address them. In some frameworks, authors
have chosen not to back invariants with a transaction at all. This
suggests a lack of user education or, perhaps alternatively,
frustration with the weak isolation guarantees.

As a community, the prevalence of weak isolation merits
reflection. Perhaps the issue is performance. In this case, we might
develop benchmarks to encourage vendors and open-source applications
into delivering fast serializability that they are not ashamed to
support or even turn on by default. Alternatively, perhaps traditional
implementations of serializability really are too slow, and recent
work on high-performance in-memory transactions~\cite{hekaton,hstore}
is critical to success. Alternatively, if serializability really
is too slow for practical workloads, then we need to develop new
programming models and new theory that application developers can
understand~\cite{coord-avoid,calm,redblue-new,writes-forest}. In any
event, the mismatch between our classic transaction model and
practical realities---as evidenced by our Rails applications
here---indicate a serious concern.

\subsection{Database-Backed Invariants}

An alternative to using transactions to enforce invariants is to
provide native support for them as first-class primitives within the
database system (thereby ``domesticating'' feral concurrency
control). In some cases---including the uniqueness validations and
foreign key associations we have studied here---many databases today
already provide native support in the form of DDL annotations that are
straightforward and are even a standard part of undergraduate database
curriculum. However, popular frameworks like Rails use databases as a
least common denominator for compatibility, primarily supporting open
source and NoSQL databases (including SQLite and MySQL) that often
provide limited support for more sophisticated constraints. This means
that the any optimizations must be in DBMS-specific drivers and will
limit portability. Moreover, even the strongest commodity databases
are insufficiently powerful to enforce the broad range of validations
we see in Rails (e.g., multi-row check constraints and UDF-based
validations).

While database-backed invariants are fraught with similar, largely
pragmatic concerns regarding vendor support and compatibility, this
latter strategy of domestication offers increased opportunity for
optimization compared to the use of transactions. In related work,
we~\cite{coord-avoid} (and others~\cite{redblue-new}) have already
begun investigating the use of invariants as a promising basis for
avoiding coordination overheads associated with serializable
execution, demonstrating considerable speedups even on traditional
OLTP workloads. Moreover, in a tiered application deployment, native
integration of user-defined validations with the database can help
eliminate database RTTs~\cite{pyxis}---which, in particular, can
assist with reducing the duration for which coordination is performed
(when it is in fact necessary). Recent work on extracting declarative
subroutines from imperative code~\cite{statusquo,writes-forest} may
allow us to automatically suggest invariants and even move closer to
the ability to detect points of coordination within imperative
code---particularly for emerging functional languages like Scala and
F\#, which encourage the use of collection types and comprehensions,
and discourage the use of mutable state.

Conceptually, Rails validations fail today largely because they are
expressed in a language that is not understood or interpreted by the
database, which is unable to assist in ensuring data integrity. Modern
commodity databases offer one \textit{general-purpose} programming
construct for ensuring data integrity: the transaction concept, as
enforced under serializable isolation. But these web programming
frameworks have adopted their \textit{own}, similar but separate set
of language idioms. This suggests the possibility of a revival of concepts from
 active and rule-based databases~\cite{activedb-book} and, broadly,
 semantic concurrency control~\cite{tamer-book}. The challenge of
 declaring semantic criteria for correctness is already being performed
 by database users---at least for some correctness criteria. While they
 are likely incomplete specifications, we view the fact that
 declarative invariants are being used organically and have been
 produced by database users (in lieu of the standard transaction model) as
 ample cause for re-evaluating the decades of work on these topics.

%  To his credit, DHH explicitly disowns the title of ``computer
% scientist'' and instead refers to himself as an ``information systems
% programmer''~\cite{dhh-keynote}. DHH's information systems are ``built
% on top of computer science...[and] computer science is what it makes
% it possible for us to do what it is that we [information systems
% programmers] do. But it doesn't define what we do.'' Can database
% systems natively support this alternative definition of correctness
% criteria (thereby ``domesticating'' feral validations)? We believe
% so. There are clear correctness implications and also performance
% implications: 

% We see opportunity for invariant- or validation-based concurrency
% control, thus allowing higher concurrency and avoiding the cost of
% serializable isolation that these data stores and users have evidently
% eschewed. This suggests the possibility of a revival of concepts from
% active and rule-based databases~\cite{activedb-book} and, broadly,
% semantic concurrency control~\cite{tamer-book}. The challenge of
% declaring semantic criteria for correctness is already being performed
% by database users---at least for some correctness criteria. While they
% are likely incomplete specifications, we view the fact that
% declarative validations are being used organically and have been
% produced by database users (in lieu of the standard transaction model) as
% ample cause for re-evaluating the decades of work on these topics.


% \minihead{A note on usability} Returning, finally, to Rails's central
% goal of programmer productivity, our results ultimately hint at a
% triumph of convenience and portability over formal---and, in some
% cases, practical---correctness guarantees. If Rails has indeed
% succeeded due to its usability and end-user productivity---despite its
% apparent lack of rigor in enforcing correctness---we believe there is
% an important takeaway for database developers. As we noted in
% Section~\ref{sec:intro}, this echoes many strains of the NoSQL
% movement; per NoSQL architect Justin Sheehy: ``What does a first-time
% user of your system experience in their first five
% minutes?''~\cite{marcus-talk}. Rails simplifies the development
% process and makes the process of getting started remarkably
% straightforward, with a suite of simple automation tools and a
% plethora of starter documentation and tutorials. In contrast, typical
% database configuration and, specifically, concurrency control
% mechanism are often less accessible. Notably, understanding the slew
% of anomalies that characterize each default isolation level---which
% were at the heart of Rails' feral validation errors---remains a
% subject of graduate-level study within
% databases~\cite{adya-isolation,hat-vldb}. We believe that
% understanding weak isolation and the interaction with validation logic
% is an important step in this direction.



% Use of weak isolation

 % Pivotal moment: ignore these use cases, or better support them?
 % Java EE!?!?
 % To do so, active database systems?
 % Drop into serializable transactions is a non-starter

 % Do not claim completeness, but nevertheless striking trends
 % Productivity-oriented programming and usability

\subsection{Closing Notes}

Regardless of the approach, we see wide opportunity (coupled with
pressing need) for future research in better supporting and optimizing
for these application patterns. We believe a blend of
application-level analyses (e.g.,~\cite{statusquo,coord-avoid}) and
pragmatically-oriented empirical study of real code
(Section~\ref{sec:conclusion}) will be instrumental to success.
