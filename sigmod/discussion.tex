
\section{Other Frameworks}
\label{sec:other-orms}

While our focus in this paper is on Rails, we briefly investigated
support for uniqueness, foreign key, and custom validations in several
other frameworks. We find widespread support for these constructs in
addition to varying degrees of susceptibility to integrity errors.

\newcommand{\orm}[1]{{\vspace{.45em}\noindent\textit{#1}}}

\orm{Java Persistence API} (JPA; version EE 7)~\cite{code-jpa} is a
standard Java Object persistence interface and supports both
uniqueness and primary key constraints in the database via specialized
object annotations. Thus, when JPA is used to create a table, it will
use the database to enforce these constraints. In 2009, JPA introduced
support for UDF validations via a JavaBean
interface~\cite{code-bean-validation}. Interestingly, both the
original (and current) Bean validation specifications specifically
address the use of uniqueness validations in their notes:
\begin{quote}
``Question: should we add @Unique that would map to @Column(unique=true)?
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part
of the [Bean Validation] spec today.''~\cite{jsr-bean}
\end{quote}
An author of a portion of the code specification notes separately:
\begin{quote}
  ``The reason @Unique is not part of the built-in constraints is the
  fact that accessing the [database] during a valiation [sic] is
  opening yourself up for potenital [sic] phantom reads. Think twice
  before you go for [an application-level] approach.''~\cite{unique-bean}
\end{quote}
%http://download.oracle.com/otn-pub/jcp/persistence-2.0-fr-eval-oth-JSpec/persistence-2_0-final-spec.pdf?AuthParam=1414639627_4654729130380ec6809634192c3faacb
By default, JPA Validations are run upon model save and run in a
transaction at the default isolation level, and therefore, as the
developers above hint, are susceptible to the same kinds of integrity
violations we study here.

\orm{Hibernate} (version 4.3.7)~\cite{code-hibernate}, a Java ORM
based on JPA, does \textit{not} automatically enforce declared foreign
key relationships: if a foreign key constraint is declared; a
corresponding column is added, but that column is \textit{not} backed by a
database foreign key. Instead, for both uniqueness and foreign key
constraints, Hibernate relies on JPA schema annotations for
correctness. Therefore, without appropriate schema annotations,
Hibernate's basic associations may contain dangling references. Hibernate also has an extensive user-level validation
framework implementing on the JPA Validation Bean
specification~\cite{code-hibernate-validator} and is sensitive to weak
isolation anomalies, similar to Rails validations.

\orm{CakePHP} (version 2.5.5)~\cite{code-cakephp}, a PHP-based web
framework, supports uniqueness, foreign key, and UDF
validations. CakePHP does \textit{not} back any of its validation
checking with a database transaction and relies on the user to
correctly specify any corresponding foreign keys or uniqueness
constraints within the database the schema. Thus, while users can
declare each of these validations, there is no guarantee that they are
actually enforced by the database. Thus, unless users are careful to
specify constraints in both their schema and in their validations,
validations may lead to integrity violations.

\orm{Laravel} (version 4.2)~\cite{code-laravel}, another PHP-based web
framework, supports the same set of functionality as CakePHP. Laravel
supports uniqueness, foreign key, and UDF validations in the
application, but any database-backed constraints must be specified
manually in the schema. Per one set of community documentation~\cite{laravel-book}, ``database-level
validations can efficiently handle some things (such as uniqueness of
a column in heavily-used tables) that can be difficult to implement
otherwise'' but ``[t]esting and maintenance is more difficult...[and]
your validations would be database- and schema-specific, which makes
migrations or switching to another database backend more difficult in
the future.'' In contrast, model-level validations are ``the
recommended way to ensure that only valid data is saved into your
database. They are database agnostic, cannot be bypassed by end users,
and are convenient to test and maintain.'' There
is no mention of concurrency in this current treatment, despite the
glaring potential for integrity errors.

\orm{Django} (version 1.7)~\cite{code-django}, a popular Python-based
framework, backs declared uniqueness and foreign key constraints with
database-level constraints. It also supports custom validations, but
these validations are not wrapped in a
transaction~\cite{code-django-constraints}. Thus, Django also appears
problematic, but only for custom validations.

\orm{Waterline} (version 0.10), a persistence layer for
node.js~\cite{code-waterline} (backing Sails.js, a popular MVC
framework written in Node.js~\cite{code-sails}), provides support for
in-DB foreign key and uniqueness constraints (when supported by the
database) as well as custom validations (that are \textit{not}
supported via transactions; e.g., ``TO-DO: This should all be wrapped
in a transaction. That's coming next but for the meantime just hope we
don't get in a nasty state where the operation
fails!''~\cite{code-waterline-txn}).

% Implementing and using unique indexes~\cite{waterline-unique-one,waterline-unique-two}.

\begin{comment}

Name & PK & FK & UDF Validations
DJANGO & Automatic & Automatic & Yes
JPA & Yes, annotation & Yes, annotation & Yes, via Beans
CakePHP & 

% Django

Supports validations
https://docs.djangoproject.com/en/dev/ref/validators/

Broken online: http://stackoverflow.com/a/5690705


1.9 (not yet released) deprecating in favor of checks
https://docs.djangoproject.com/en/1.7/internals/deprecation/

checks:
https://docs.djangoproject.com/en/1.7/topics/checks/



%FK 

does it right
https://docs.djangoproject.com/en/1.7/ref/models/fields/#django.db.models.ForeignKey

%PK

does it right, by default declares an index
https://docs.djangoproject.com/en/1.7/_modules/django/db/backends/schema/


'''
If True, this field must be unique throughout the table.

This is enforced at the database level and by model validation. If you try to save a model with a duplicate value in a unique field, a django.db.IntegrityError will be raised by the model’s save() method.

This option is valid on all field types except ManyToManyField, OneToOneField, and FileField.

Note that when unique is True, you don’t need to specify db_index, because unique implies the creation of an index.
'''
a

% Hibernate/JPA


%FK 

no FK by default, relies on JPA
http://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html/ch08.html

JoinColumn
http://docs.oracle.com/javaee/6/api/javax/persistence/OneToMany.html

%PK

``The reason @Unique is not part of the built-in constraints is the fact that accessing the Session/EntityManager during a valiation is opening yourself up for potenital phantom reads. Think twice before you go for the following approach.''
https://developer.jboss.org/wiki/AccessingtheHibernateSessionwithinaConstraintValidator?_sscc=t
http://stackoverflow.com/questions/17092601/validate-unique-username-in-spring

http://docs.oracle.com/javaee/6/api/javax/persistence/UniqueConstraint.html

BEAN supported
https://jcp.org/en/jsr/detail?id=303

%CakePHP
supports udf validations
http://book.cakephp.org/2.0/en/models/data-validation.html

basically you set up your own schema, but default validations don't
appear to be transactional

%FK 


%PK

https://github.com/cakephp/cakephp/blob/50b3893e6507979427e1aaeb435494aed1af4f52/lib/Cake/Model/Model.php#L3303


% Laravel

Manually define database schema!

%FK 
%PK

http://laravel.com/docs/4.2/validation#rule-unique
https://github.com/laravel/framework/blob/75b1dff27778354e44511556171cf6ae466c8b59/src/Illuminate/Validation/Validator.php#L940


http://laravelbook.com/laravel-input-validation/

% Node -- Sail.js
%FK 
%PK

Validations are handled by Anchor, a thin layer on top of Validator, one of the most robust validation libraries for Node.js. Sails supports most of the validations available in Validator, as well as a few extras that require database integration, like unique.

http://sailsjs.org/#/documentation/concepts/ORM/Validations.html
https://github.com/balderdashy/sails/issues/832

https://github.com/balderdashy/waterline

Broken in Mongo
https://github.com/balderdashy/sails-mongo/issues/152

Broken in dev
https://github.com/balderdashy/waterline/issues/55

Because you have migrate: safe set the indexes will not be created when you start the ORM.
https://github.com/balderdashy/waterline/issues/236

uses db foreign keys

\end{comment}

% what can we learn?
% udfs


\section{Database System Implications}
\label{sec:discussion}

In this section, we discuss the implications of this study's results
for future database systems designs and research.

In Rails and, across the other ORMs we studied, the use of
application-enforced validations was surprisingly common. The
inclusion of validations in a framework as mature as the Java EE JPA
specification (which includes effort from with 41 representatives from
companies including Google, Oracle, and Red Hat), suggests that
validations are, in fact, a common way to express domain logic in web
frameworks (and are not simply an artifact of Rails). We believe that
appropriate enforcement of these validations should therefore be an
important concern for database management systems.

\minihead{Enforcing validations} Among the frameworks we have studied,
we can identify three main approaches to validation enforcement:
\begin{defendenumerate}
\item Let the application enforce the validations, and also let
  the application prevent concurrency anomalies.

\item Let the application enforce the validations, and use database
  transactions to mediate between concurrent validations and updates.

\item Let the database perform validations (e.g., by declaring a unique
  index on a column that is supposed to be unique)
\end{defendenumerate}
In our Rails corpus, the second approach is most prevalent. However,
under (often default) non-serializable isolation, this approach is
insufficient to correctly enforce concurrent
validations. Non-serializable isolation is \textit{sometimes} okay,
but it is not a general solution for arbitrary invariants. As a
consequence, users today must effectively roll their own solutions
without the assistance of the database---the first approach---or
otherwise risk inconsistency.

We see two primary avenues for improving validation support.

\minihead{Address weak isolation} First, we can ensure that
transaction-backed validations run under appropriate isolation. In an
ideal world, transaction isolation would default to serializable
isolation (without bugs). When default database isolation is
non-serializable, one can only expect ``convention over
configuration'' to lead to isolation anomalies.

There are several pragmatic challenges here. However, lack of support
for serializable isolation in databases such as Oracle 12c and
implementation bugs such as the error we encountered in PostgreSQL
raise portability challenges. There is compelling evidence that some
framework authors \textit{are} aware of this issue (e.g.,
Footnote~\ref{fn:si-rails}, the JPA comments in
Section~\ref{sec:other-orms}). However, despite this awareness,
integrity violations are still possible, and, in some frameworks,
authors have chosen not to back validations with a transaction at
all. This suggests a lack of user education or, alternatively,
frustration with the existing prevalence of weak isolation techniques.

Nevertheless, better understanding when weak isolation models
\textit{as deployed in production databases} are sufficient for and
when stronger levels are required would be an excellent start.

\minihead{Natively supporting validations} Second, we can consider
greater in-database support for validations. That is, while databases
today provide support for limited forms of constraints (including
uniqueness, referential integrity, and row-level check constraints),
typical database constraint support is insufficient to express the
broad range of validations we see in Rails.

Conceptually, Rails validations fail today largely because they are
expressed in a language that is not understood or interpreted by the
database, which is unable to assist in ensuring data integrity. Modern
commodity databases offer one \textit{general-purpose} programming
construct for ensuring data integrity: the transaction concept, as
enforced under serializable isolation. But these web programming
frameworks have adopted their \textit{own}, similar but separate set
of language idioms.

To his credit, DHH explicitly disowns the title of ``computer
scientist'' and instead refers to himself as an ``information systems
programmer''~\cite{dhh-keynote}. DHH's information systems are ``built
on top of computer science...[and] computer science is what it makes
it possible for us to do what it is that we [information systems
programmers] do. But it doesn't define what we do.'' Can database
systems natively support this alternative definition of correctness
criteria (thereby ``domesticating'' feral validations)? We believe
so. There are clear correctness implications and also performance
implications: in a tiered application deployment, native integration
of user-defined validations with the database can help eliminate
database RTTs~\cite{pyxis}---which, in particular, can assist with
reducing the duration for which locks are held.

We see opportunity for invariant- or validation-based concurrency
control, thus allowing higher concurrency and avoiding the cost of
serializable isolation that these data stores and users have evidently
eschewed. This suggests the possibility of a revival of concepts from
active and rule-based databases~\cite{activedb-book} and, broadly,
semantic concurrency control. The challenge of declaring semantic
criteria for correctness is already being performed by database
users---at least for some correctness criteria. While they are likely
incomplete specifications, we view the fact that declarative
validations are being used organically and have been produced by
database users (in lieu of standard transaction model) as ample cause
for re-evaluating the decades of work on semantic concurrency control~\cite{tamer-book}.

\minihead{A note on usability} Returning, finally, to Rails's central
goal of programmer productivity, our results ultimately hint at a
triumph of convenience and portability over formal---and, in some
cases, practical---correctness guarantees. If Rails has indeed
succeeded due to its usability and end-user productivity---despite its
apparent lack of rigor in enforcing correctness---we believe there is
an important takeaway for database developers. As we noted in
Section~\ref{sec:intro}, this echoes many strains of the NoSQL
movement; per NoSQL architect Justin Sheehy: ``What does a
first-time user of your system experience in their first five
minutes?''~\cite{marcus-talk}. Rails simplifies the development
process and makes the process of getting started remarkably
straightforward, with a suite of simple automation tools and a
plethora of starter documentation and tutorials. In contrast, typical
database configuration is often less accessible. Notably,
understanding the slew of anomalies that characterize each default
isolation level---which were at the heart of Rails' feral validation
errors---remains a subject of graduate-level study within
databases~\cite{adya-isolation,hat-vldb}. We believe that
understanding weak isolation and the interaction with validation logic
is an important step in this direction.


% Use of weak isolation

 % Pivotal moment: ignore these use cases, or better support them?
 % Java EE!?!?
 % To do so, active database systems?
 % Drop into serializable transactions is a non-starter

 % Do not claim completeness, but nevertheless striking trends
 % Productivity-oriented programming and usability