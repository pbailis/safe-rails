
\section{Other Frameworks}
\label{sec:other-orms}

While our focus in this paper is on Rails, we briefly investigated
support for uniqueness, foreign key, and custom validations in several
other frameworks. We find widespread support for these constructs in
addition to varying degrees of susceptibility to integrity errors.

\newcommand{\orm}[1]{{\vspace{.45em}\noindent\textit{#1}}}

\orm{Java Persistence API} (JPA; version EE 7)~\cite{code-jpa} is a
standard Java Object persistence interface and supports both
uniqueness and primary key constraints in the database via specialized
object annotations. Thus, when JPA is used to create a table, it will
use the database to enforce these constraints. In 2009, JPA introduced
support for UDF validations via a JavaBean
interface~\cite{code-bean-validation}. Interestingly, both the
original (and current) Bean validation specifications specifically
address the use of uniqueness validations in their notes:
\begin{quote}
``Question: should we add @Unique that would map to @Column(unique=true)?
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part
of the [Bean Validation] spec today.''~\cite{jsr-bean}
\end{quote}
An author of a portion of the code specification notes separately:
\begin{quote}
  ``The reason @Unique is not part of the built-in constraints is the
  fact that accessing the [database] during a valiation [sic] is
  opening yourself up for potenital [sic] phantom reads. Think twice
  before you go for [an application-level] approach.''~\cite{unique-bean}
\end{quote}
%http://download.oracle.com/otn-pub/jcp/persistence-2.0-fr-eval-oth-JSpec/persistence-2_0-final-spec.pdf?AuthParam=1414639627_4654729130380ec6809634192c3faacb
By default, JPA Validations are run upon model save and run in a
transaction at the default isolation level, and therefore, as the
developers above hint, are susceptible to the same kinds of integrity
violations we study here.

\orm{Hibernate} (version 4.3.7)~\cite{code-hibernate}, a Java ORM
based on JPA, does \textit{not} automatically enforce declared foreign
key relationships: if a foreign key constraint is declared; a
corresponding column is added, but that column is \textit{not} backed by a
database foreign key. Instead, for both uniqueness and foreign key
constraints, Hibernate relies on JPA schema annotations for
correctness. Therefore, without appropriate schema annotations,
Hibernate's basic associations may contain dangling references. Hibernate also has an extensive user-level validation
framework implementing on the JPA Validation Bean
specification~\cite{code-hibernate-validator} and is sensitive to weak
isolation anomalies, similar to Rails validations.

\orm{CakePHP} (version 2.5.5)~\cite{code-cakephp}, a PHP-based web
framework, supports uniqueness, foreign key, and UDF
validations. CakePHP does \textit{not} back any of its validation
checking with a database transaction and relies on the user to
correctly specify any corresponding foreign keys or uniqueness
constraints within the database the schema. Thus, while users can
declare each of these validations, there is no guarantee that they are
actually enforced by the database. Thus, unless users are careful to
specify constraints in both their schema and in their validations,
validations may lead to integrity violations.

\orm{Laravel} (version 4.2)~\cite{code-laravel}, another PHP-based web
framework, supports the same set of functionality as CakePHP. Laravel
supports uniqueness, foreign key, and UDF validations in the
application, but any database-backed constraints must be specified
manually in the schema. Per one set of community documentation~\cite{laravel-book}, ``database-level
validations can efficiently handle some things (such as uniqueness of
a column in heavily-used tables) that can be difficult to implement
otherwise'' but ``[t]esting and maintenance is more difficult...[and]
your validations would be database- and schema-specific, which makes
migrations or switching to another database backend more difficult in
the future.'' In contrast, model-level validations are ``the
recommended way to ensure that only valid data is saved into your
database. They are database agnostic, cannot be bypassed by end users,
and are convenient to test and maintain.'' There
is no mention of concurrency in this current treatment, despite the
glaring potential for integrity errors.

\orm{Django} (version 1.7)~\cite{code-django}, a popular Python-based
framework, backs declared uniqueness and foreign key constraints with
database-level constraints. It also supports custom validations, but
these validations are not wrapped in a
transaction~\cite{code-django-constraints}. Thus, Django also appears
problematic, but only for custom validations.

\orm{Waterline} (version 0.10), a persistence layer for
node.js~\cite{code-waterline} (backing Sails.js, a popular MVC
framework written in Node.js~\cite{code-sails}), provides support for
in-DB foreign key and uniqueness constraints (when supported by the
database) as well as custom validations (that are \textit{not}
supported via transactions; e.g., ``TO-DO: This should all be wrapped
in a transaction. That's coming next but for the meantime just hope we
don't get in a nasty state where the operation
fails!''~\cite{code-waterline-txn}).

% Implementing and using unique indexes~\cite{waterline-unique-one,waterline-unique-two}.

\begin{comment}

Name & PK & FK & UDF Validations
DJANGO & Automatic & Automatic & Yes
JPA & Yes, annotation & Yes, annotation & Yes, via Beans
CakePHP & 

% Django

Supports validations
https://docs.djangoproject.com/en/dev/ref/validators/

Broken online: http://stackoverflow.com/a/5690705


1.9 (not yet released) deprecating in favor of checks
https://docs.djangoproject.com/en/1.7/internals/deprecation/

checks:
https://docs.djangoproject.com/en/1.7/topics/checks/



%FK 

does it right
https://docs.djangoproject.com/en/1.7/ref/models/fields/#django.db.models.ForeignKey

%PK

does it right, by default declares an index
https://docs.djangoproject.com/en/1.7/_modules/django/db/backends/schema/


'''
If True, this field must be unique throughout the table.

This is enforced at the database level and by model validation. If you try to save a model with a duplicate value in a unique field, a django.db.IntegrityError will be raised by the model’s save() method.

This option is valid on all field types except ManyToManyField, OneToOneField, and FileField.

Note that when unique is True, you don’t need to specify db_index, because unique implies the creation of an index.
'''
a

% Hibernate/JPA


%FK 

no FK by default, relies on JPA
http://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html/ch08.html

JoinColumn
http://docs.oracle.com/javaee/6/api/javax/persistence/OneToMany.html

%PK

``The reason @Unique is not part of the built-in constraints is the fact that accessing the Session/EntityManager during a valiation is opening yourself up for potenital phantom reads. Think twice before you go for the following approach.''
https://developer.jboss.org/wiki/AccessingtheHibernateSessionwithinaConstraintValidator?_sscc=t
http://stackoverflow.com/questions/17092601/validate-unique-username-in-spring

http://docs.oracle.com/javaee/6/api/javax/persistence/UniqueConstraint.html

BEAN supported
https://jcp.org/en/jsr/detail?id=303

%CakePHP
supports udf validations
http://book.cakephp.org/2.0/en/models/data-validation.html

basically you set up your own schema, but default validations don't
appear to be transactional

%FK 


%PK

https://github.com/cakephp/cakephp/blob/50b3893e6507979427e1aaeb435494aed1af4f52/lib/Cake/Model/Model.php#L3303


% Laravel

Manually define database schema!

%FK 
%PK

http://laravel.com/docs/4.2/validation#rule-unique
https://github.com/laravel/framework/blob/75b1dff27778354e44511556171cf6ae466c8b59/src/Illuminate/Validation/Validator.php#L940


http://laravelbook.com/laravel-input-validation/

% Node -- Sail.js
%FK 
%PK

Validations are handled by Anchor, a thin layer on top of Validator, one of the most robust validation libraries for Node.js. Sails supports most of the validations available in Validator, as well as a few extras that require database integration, like unique.

http://sailsjs.org/#/documentation/concepts/ORM/Validations.html
https://github.com/balderdashy/sails/issues/832

https://github.com/balderdashy/waterline

Broken in Mongo
https://github.com/balderdashy/sails-mongo/issues/152

Broken in dev
https://github.com/balderdashy/waterline/issues/55

Because you have migrate: safe set the indexes will not be created when you start the ORM.
https://github.com/balderdashy/waterline/issues/236

uses db foreign keys

\end{comment}

% what can we learn?
% udfs


\section{Implications for Databases}
\label{sec:discussion}

This study highlights an important trend within common ORM systems and
ORM-backed applications: the use of feral invariants. As we have seen,
as implemented in practice, these invariants are not well-supported by
today's database systems---evidence of the continued impedance
mismatch between application writers and database systems. In light of
these findings, in this section, we reflect upon this mismatch and
make make several concrete, positive proposals for the database
systems community.

\subsection{Shortcomings Today}

Core to our findings is a lack of database support for these
feral mechanisms. In effect, today's databases effectively offer two
primary options for ORM framework developers and users:

\begin{impenumerate}
\item \textbf{Use ACID transactions.} In principle, serializable
  transactions would be sufficient to correctly enforce arbitrary
  database invariants. This is core to the transaction concept:
  isolation is a means towards preserving integrity. \vspace{.5em}

  \indent In practice, for application developers, ACID is a broken
  promise. Given its performance and availability
  overheads~\cite{brewer-cap}, developers at scale have largely
  eschewed the use of serializable transactions, which are not
  required for correct enforcement of approximately 75\% of the
  invariants we encountered in the Rails corpus. More pragmatically,
  many databases offering ``ACID'' semantics do not provide
  serializability by default and often, even among industry-standard
  enterprise offerings, offer it as an option at all~\cite{hat-vldb}
  (to say nothing of implementation difficulties, as in
  Footnote~\ref{fn:pg-bug}). Instead, these developers must manually
  reason about a host of complex, often obscure, and poorly understood
  weak isolation models expressed interms of low-level read/write
  anomalies such as Write Skew and Lost
  Update~\cite{adya-isolation,consistency-borders}. We have observed
  (e.g., Footnote~\ref{fn:si-rails}) that ORM and expert application
  developers are familiar with this mislabeling. This
  misrepresentation may even play a role in the relative unpopularity
  of transactions within the web programming community.

\item\textbf{Do it yourself (ferally).} In principle, hand-rolling
  user-level concurrency control solutions on a per-framework
  or, worse, per-application basis is an expensive, error-prone, and
  difficult process that neglects decades of intellectual achievement
  in the database community.\vspace{.5em}
  
  In practice, hand-rolling user-level concurrency control solutions
  is an expensive, error-prone, and difficult process. While this
  solution is often sufficient to maintain correctness in the
  approximately 75\% I-confluent feral invariants, the remainder
  can---in modern ORM implementations---lead to data corruption on
  behalf of applications. However, and perhaps most importantly, this
  feral approach preserves a key tenet of the Rails philosophy: a
  recurring insistence on expressing domain logic in the application.
\end{impenumerate}

In summary, neither of these solutions is good. Serializability is too
expensive for some applications, is not widely supported, and is not
necessary for many application invariants. Feral concurrency control
is often less expensive and is trivially portable but is not
sufficient for many other application invariants. In neither case does
the database respect application programmer wishes for a clean,
evidently idiomatic means of expressing correctness criteria in domain
logic.

\subsection{Domesticating Feral Mechanisms}

Constructively, we believe that, to properly provide database support
and thereby ``domesticate'' these feral mechanisms, application users
and framework authors need a new interface to the database will enable
them to:
\begin{interfaceenumerate} 
\item \textit{Express correctness criteria in the language of their
    domain model with minimal friction while permitting their
    automatic enforcement.} Per Section~\ref{sec:motivation}, a core
  factor behind the success of ORMs like Rails appears to be their
  promulgation of an idiomatic programming style that ``seems right''
  for web programming. We believe any solution to domestication must
  respect these patterns and programming style, including the ability
  to specify invariants in a framework's native language. Ideally, ORM
  programmers could enforce their existing invariants (and have them
  automatically enforced) without modification. This is already
  feasible for a subset of invariants---like uniqueness and foreign
  key constraints---but not all. An ideal solution to domestication
  would provide universal support.

\item \textit{Only pay the price of coordination when necessary.} Per
  Section~\ref{sec:apps}, many invariants can be safely executed
  without coordination, while others cannot. An ideal solution to
  domestication would enable applications to avoid coordination
  whenever possible would improve performance and operation
  availability, thus bypassing a common criticism of serializable
  transactions.

\item \textit{Easily deploy to multiple database backends.}  ORM
  frameworks today are deployed across a range of database
  implementations, and, when deciding which database features to
  exercise, framework authors often choose the least common
  denominator for compatibility purposes. An ideal solution to
  domestication would preserve this compatibility.

\end{interfaceenumerate}
While fulfilling these design requirements represents a considerable
challenge, we believe the search for a solution is both worthwhile and
of imminent practical importance.

The actual vector for implementing this interface is an open question,
but the literature lends several clues. On the one hand, we do not
believe the answer lies in exposing additional read/write isolation or
consistency guarantees like Read Committed; these fail our requirement
for an abstraction operating the level of domain logic and, as we have
noted, are challenging for developers (and researchers) to reason
about. On the other hand, more recent proposals for invariant-based
concurrency control~\cite{redblue-new,coord-avoid} and a litany of
work from prior decades on rule-based~\cite{activedb-book} and,
broadly, semantics-based concurrency control~\cite{tamer-book} appear
immediately applicable and worth (re-)considering. Recent advances in
program analysis for extracting invariants~\cite{writes-forest} and
subroutines from imperative code~\cite{statusquo} may allow us to
programatically suggest new invariants, perform correspondence
checking for existing applications, and apply a range of automated
optimizations~\cite{pyxis}. Finally, clean-slate language design and
analysis obviate the need for explicit invariant declaration (thus
alleviating concerns of specification
completeness)~\cite{calm,blazes}; while adoption within the ORM
community is a challenge, we view this exploration as worthwhile.

In all, the wide gap between research and current practice is both a
pressing concern and an exciting opportunity to revisit many decades of
research on alternatives to serializability with an eye towards
current operating conditions, application demands, and programmer
practices. Our proposal here is demanding, but so are the framework
and application writers our databases serve. While the latest
incarnation of the ORM vision may have passed over database
concurrency control, the dream is not (yet) lost.
