
\section{Other Frameworks}
\label{sec:other-orms}

While our focus in this paper is on Rails, we briefly investigated
support for (problematic, in Rails) uniqueness, foreign key, and
custom validations in several other frameworks.

\newcommand{\orm}[1]{{\vspace{.45em}\noindent\textit{#1}}}

\orm{Java Persistence API} (JPA; version EE 7)~\cite{code-jpa} is a
standard Java Object persistence interface and supports both
uniqueness and primary key constraints in the database via specialized
object annotations. Thus, when JPA is used to create a table, it will
use the database to enforce these constraints. In 2009, JPA introduced
support for UDF validations via a JavaBean
interface~\cite{code-bean-validation}. Interestingly, both the
original (and current) Bean validation specifications specifically
address the use of uniqueness validations in their notes:
\begin{quote}
``Question: should we add @Unique that would map to @Column(unique=true)?
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part
of the [Bean Validation] spec today.''~\cite{jsr-bean}
\end{quote}
An author of a portion of the code specification notes separately:
\begin{quote}
  ``The reason @Unique is not part of the built-in constraints is the
  fact that accessing the [database] during a valiation [sic] is
  opening yourself up for potenital [sic] phantom reads. Think twice
  before you go for [an application-level] approach.''~\cite{unique-bean}
\end{quote}
%http://download.oracle.com/otn-pub/jcp/persistence-2.0-fr-eval-oth-JSpec/persistence-2_0-final-spec.pdf?AuthParam=1414639627_4654729130380ec6809634192c3faacb
By default, JPA Validations are triggered pre-commit upon model change
and therefore run in a transaction (at the default isolation level).

\orm{Hibernate} (version 4.3.7)~\cite{code-hibernate}, a Java ORM
based on JPA, does \textit{not} automatically enforce declared foreign
key relationships: if a foreign key constraint is declared; a
corresponding column is added, but that column is not backed by a
database foreign key. Instead, for both uniqueness and foreign key
constraints, Hibernate relies on JPA schema annotations for
correctness. Hibernate also has an extensive user-level validation
framework implementing on the JPA Validation Bean
specification~\cite{code-hibernate-validator}.

\orm{CakePHP} (version 2.5.5)~\cite{code-cakephp}, a PHP-based web
framework, supports uniqueness, foreign key, and UDF
validations. CakePHP does \textit{not} back any of its validation
checking with a database transaction and relies on the user to
correctly specify any corresponding foreign keys or uniqueness
constraints within the database the schema. Thus, while users can
declare each of these validations, there is no guarantee that they are
actually enforced by the database.

\orm{Laravel} (version 4.2)~\cite{code-laravel}, another PHP-based web
framework, supports the same set of functionality as CakePHP. Laravel
supports uniqueness, foreign key, and UDF validations in the
application, but any database-backed constraints must be specified
manually in the schema. Per one set of community documentation~\cite{laravel-book}, ``database-level
validations can efficiently handle some things (such as uniqueness of
a column in heavily-used tables) that can be difficult to implement
otherwise'' but ``[t]esting and maintenance is more difficult...[and]
your validations would be database- and schema-specific, which makes
migrations or switching to another database backend more difficult in
the future.'' In contrast, model-level validations are ``the
recommended way to ensure that only valid data is saved into your
database. They are database agnostic, cannot be bypassed by end users,
and are convenient to test and maintain.'' There
is no mention of concurrency in this current treatment.

\orm{Django} (version 1.7)~\cite{code-django}, a popular Python-based
framework, backs declared
uniqueness and foreign key constraints with database-level
constraints. It also supports custom validations, but these
validations are not wrapped
in a transaction (e.g.,~\cite{code-django-constraints}).

\orm{Waterline} (version 0.10), a persistence layer for
node.js~\cite{code-waterline} (backing Sails.js, a popular MVC
framework written in Node.js~\cite{code-sails}), provides support for
in-DB foreign key and uniqueness constraints (when supported by the
database) as well as custom validations (without transaction support;
e.g., ``TO-DO: This should all be wrapped in a transaction. That's
coming next but for the meantime just hope we don't get in a nasty
state where the operation
fails!''~\cite{code-waterline-txn}).

% Implementing and using unique indexes~\cite{waterline-unique-one,waterline-unique-two}.

\minihead{Summary} The use of validations appears to be common
practice; the inclusion of validations in (and associated review
processes associated with) a mature, Enterprise-grade programming
environment as Java EE suggests that, in fact, users appreciate
domain-specific validation. The care with which validations are
applied, however, is domain-dependent. While the Java EE developers
appear familiar with database anomalies, as we have seen, their more
lackadaisical Rails implementation can cause serious issues. While
frameworks such as Django correctly enforce constraints in the
database, it is surprising to see both PHP-based
frameworks rely on the user to declare in-database constraints
\textit{while still} supporting totally feral application-level
constraints. This again suggests an enforcement strategy similar to
that of Rails. However, while Rails automatically generates schemas,
the onus in these frameworks is potentially greater on the end-user as
she is responsible for ultimately declaring schema migrations.


\begin{comment}

Name & PK & FK & UDF Validations
DJANGO & Automatic & Automatic & Yes
JPA & Yes, annotation & Yes, annotation & Yes, via Beans
CakePHP & 

% Django

Supports validations
https://docs.djangoproject.com/en/dev/ref/validators/

Broken online: http://stackoverflow.com/a/5690705


1.9 (not yet released) deprecating in favor of checks
https://docs.djangoproject.com/en/1.7/internals/deprecation/

checks:
https://docs.djangoproject.com/en/1.7/topics/checks/



%FK 

does it right
https://docs.djangoproject.com/en/1.7/ref/models/fields/#django.db.models.ForeignKey

%PK

does it right, by default declares an index
https://docs.djangoproject.com/en/1.7/_modules/django/db/backends/schema/


'''
If True, this field must be unique throughout the table.

This is enforced at the database level and by model validation. If you try to save a model with a duplicate value in a unique field, a django.db.IntegrityError will be raised by the model’s save() method.

This option is valid on all field types except ManyToManyField, OneToOneField, and FileField.

Note that when unique is True, you don’t need to specify db_index, because unique implies the creation of an index.
'''
a

% Hibernate/JPA


%FK 

no FK by default, relies on JPA
http://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html/ch08.html

JoinColumn
http://docs.oracle.com/javaee/6/api/javax/persistence/OneToMany.html

%PK

``The reason @Unique is not part of the built-in constraints is the fact that accessing the Session/EntityManager during a valiation is opening yourself up for potenital phantom reads. Think twice before you go for the following approach.''
https://developer.jboss.org/wiki/AccessingtheHibernateSessionwithinaConstraintValidator?_sscc=t
http://stackoverflow.com/questions/17092601/validate-unique-username-in-spring

http://docs.oracle.com/javaee/6/api/javax/persistence/UniqueConstraint.html

BEAN supported
https://jcp.org/en/jsr/detail?id=303

%CakePHP
supports udf validations
http://book.cakephp.org/2.0/en/models/data-validation.html

basically you set up your own schema, but default validations don't
appear to be transactional

%FK 


%PK

https://github.com/cakephp/cakephp/blob/50b3893e6507979427e1aaeb435494aed1af4f52/lib/Cake/Model/Model.php#L3303


% Laravel

Manually define database schema!

%FK 
%PK

http://laravel.com/docs/4.2/validation#rule-unique
https://github.com/laravel/framework/blob/75b1dff27778354e44511556171cf6ae466c8b59/src/Illuminate/Validation/Validator.php#L940


http://laravelbook.com/laravel-input-validation/

% Node -- Sail.js
%FK 
%PK

Validations are handled by Anchor, a thin layer on top of Validator, one of the most robust validation libraries for Node.js. Sails supports most of the validations available in Validator, as well as a few extras that require database integration, like unique.

http://sailsjs.org/#/documentation/concepts/ORM/Validations.html
https://github.com/balderdashy/sails/issues/832

https://github.com/balderdashy/waterline

Broken in Mongo
https://github.com/balderdashy/sails-mongo/issues/152

Broken in dev
https://github.com/balderdashy/waterline/issues/55

Because you have migrate: safe set the indexes will not be created when you start the ORM.
https://github.com/balderdashy/waterline/issues/236

uses db foreign keys

\end{comment}


% what can we learn?
% udfs


\section{Database System Implications}
\label{sec:discussion}

In this section, we discuss the implications of this study's results
for future database systems designs and research.

\subsection{Designing for Feral Validations}

In Rails and, across the other ORMs we studied, the use of
application-enforced validations was surprisingly common. The
inclusion of validations in the Java EE JPA specification (including
effort from with 41 representatives from companies including Google,
Oracle, and Red Hat), suggests that validations are, in fact, a common
way to express domain logic in web programs. We believe that
appropriate support for these validations should therefore be an
important concern of database management systems. Unfortunately,
support for enforcing validations is limited, and validations are
often insufficient to prevent integrity errors. As we have seen, Rails
validations as deployed in today's database systems may corrupt
data. Among the frameworks we have studied, we can identify three main
approaches to validation enforcement:
\begin{defendenumerate}
\item Let the the application enforce the validations, and also let
  the application prevent concurrency anomalies.

\item Let the application enforce the validations, and use database
  transactions to mediate between concurrent validations and updates.

\item Let the database the perform validations (e.g. by declaring a unique
  index on a column that is supposed to be unique)
\end{defendenumerate}
As we have seen, in practice, the second approach is most prevalent in
Rails applications. However, under default, non-serializable
isolation, this approach is unsufficient to correctly enforce
concurrent validations. Non-serializable isolation is
\textit{sometimes} okay, but it is not a general solution for
arbitrary invariants. As a consequence, users today must effectively
roll their own solutions---the first approach---or otherwise risk
inconsistency.

We see two primary avenues for improving validation support.

\minihead{Fixing weak isolation} First, we can ensure that
validator-based transactions run under appropriate isolation. In an
ideal world, transaction isolation would default to serializable
isolation (without bugs). (When default database isolation is
non-serializable, one can only expect ``convention over
configuration'' to lead to isolation anomalies.)  its lack of support
in databases such as Oracle 12c and implementation bugs such as the
error we encountered in PostgreSQL are often enough to compromise
validator integrity. A community that shuns transaction use is even
less likely to positively engage with the subtleties of weak
isolation.  In the real world, we believe weak isolation suffers from
an education problem among developers. There is compelling evidence
that some framework authors \textit{are} aware of this issue (e.g.,
Footnote~\ref{fn:si-rails}, the JPA comments in
Section~\ref{sec:other-orms}). However, many of these anomalies could
be remedied by setting the validation isolation level to serializable
isolation or otherwise making greater use of existing language-level
support like \texttt{SELECT FOR UPDATE}.

\minihead{Natively supporting validations} Second, and perhaps more
interestingly, we can consider greater in-database support for
validations. That is, while database today provide support for limited
forms of constraints (including uniqueness, referential integrity, and
row-level check constraints), we can consider broader support for
declarative UDF-based constraints.

Conceptually, these validations fail today largely because they are
expressed in a language that is not understood or interpreted by the
database, which is unable to assist in ensuring data integrity. Today,
commodity databases offer one general-purpose programming construct
for ensuring data integrity: the transaction concept. But these web
programming frameworks have adopted their \textit{own}, similar but
separate set of language idioms. To his credit, DHH explicitly disowns
the title of ``computer scientist'' and instead refers to himself as
an ``information systems programmer''~\cite{dhh-keynote}. DHH's
information systems are ``built on top of computer science...[and]
computer science is what it makes it possible for us to do what it is
that we [information systems programmers] do. But it doesn't define
what we do.'' Given a set of database system implementations that
necessarily require buy-in to a transactional programming model in
order to support concurrent programming (not to mention the
complexities associated with weak isolation), DHH and the Rails
community instead have forged their own path.

Can database systems natively support DHH and company's feral
validations (thereby ``domesticating'' them)?  Doing so has clear
correctness implications but also has performance implications: in a
tiered application deployment, native integration of user-defined
validations with the database can help eliminate database
RTTs~\cite{pyxis}---which, in particular, can assist with reducing the
duration for which locks are held. We see opportunity for invariant-
or validation-based concurrency control, thus allowing higher
concurrency and avoiding the cost of serializable isolation that these
data stores and users have evidently eschewed. This suggests the
possibility of a revival of concepts from active and rule-based
databases~\cite{activedb-book} and, broadly, semantic concurrency
control. The challenge of declaring semantic criteria for correctness
is already being performed by database users---at least for some
correctness criteria. While they are likely incomplete specifications,
we view the fact that declarative validations are being used
organically and have been produced by database users (in lieu of
standard transaction model) as ample cause for re-evaluating the
decades of work on semantic concurrenty control.


\subsection{Usability and ``Correctness''}

Returning, finally, to the Rails central goal of programmer
productivity, our results ultimately hint at a triumph of convenience
over formal---and, in some cases, practical---correctness
guarantees. However, we have observed that the ``convenient'' feral
validations actually do serve a purpose in reducing worst-case data
integrity errors. This suggests that, in fact, these validations are
somehow sufficient for most applications, or, alternatively, other
errors (e.g., bugs in program logic) loom larger for developers.

The takeaway for the database community here is, in a sense, somewhat
sobering. Ultimately, under the hypothesis that Rails has succeeded
due to its usability and productivity, conventional databases have
largely failed to provide the same end-user efficiency. As we noted in
Section~\ref{sec:intro}, this echoes many strains of the NoSQL
movement; per Basho's Justin Sheehy: ``What does a first-time user of
your system experience in their first five
minutes?''~\cite{marcus-talk}. Rails simplifies the development
process and makes the process of getting started remarkably
straightforward, with a suite of simple automation tools and a
plethora of starter documentation and tutorials. In contrast, typical
database configuration is often less accessible. Moreover
understanding, for example, the slew of anomalies that characterize
each isolation level (which also vary between stores), remains a
subject of graduate-level study within
databases~\cite{adya-isolation,hat-vldb}. Moreover, a first-time user
is unlikely to run a highly concurrent workload and experience such
integrity violations; rather, it is only at scale that they might
encounter them.

The resulting opportunity is to develop database systems that provide
usability at both the early stages and, subsequently, at later
stages. We are by no means the first to make this
observation. However, in the context of modern web frameworks, it is
our perogative to better support these users who, otherwise, appear
content to ignore much of the technological advances within the
database community of the last four decades and continue to use
productive if unsafe programming patterns.


% Use of weak isolation

 % Pivotal moment: ignore these use cases, or better support them?
 % Java EE!?!?
 % To do so, active database systems?
 % Drop into serializable transactions is a non-starter

 % Do not claim completeness, but nevertheless striking trends
 % Productivity-oriented programming and usability