
\section{Introduction}
\label{sec:intro}

The rise of ``Web 2.0'' Internet applications delivering dynamic, highly
interactive user experiences has been accompanied by a new generation
of programming frameworks~\cite{web20}. These frameworks simplify
common tasks such as content templating and presentation, request
handling, and, notably, data storage, allowing developers to focus on
``agile'' development of their applications. These frameworks embody
the most recent realization of the vision of object-relational mapping
(ORM) systems~\cite{orm-db}, albeit at a unprecedented scale of deployment and
programmer adoption.

A central player among modern frameworks is Ruby on Rails (or, simply,
``Rails'')~\cite{rails-book,rails-computer}, an open source codebase
powering sites including (at one point) Twitter~\cite{twitter-rails},
Airbnb~\cite{airbnb-rails}, GitHub~\cite{github-rails},
Hulu~\cite{hulu-rails}, Shopify~\cite{shopify-rails},
Groupon~\cite{groupon-rails}, SoundCloud~\cite{soundcloud-rails},
Twitch~\cite{twitch-rails}, Goodreads~\cite{goodreads-rails}, and
Zendesk~\cite{zendesk-rails}. From the perspective of database systems
research, Rails is interesting for at least two reasons. First, it
continues to be a popular means of developing responsive web
application front-end and business logic, with an active open source
community and user base. Rails recently celebrated its tenth
anniversary and enjoys considerable commercial interest, both in terms
of deploy base and the availability of hosted ``cloud'' deployment
environments such as Heroku. Thus, Rails programmers represent a large
class of consumers of database technology. Second, and perhaps more
importantly, Rails is ``opinionated
software''~\cite{dhh-opinionated}. That is, Rails embodies the strong
personal convictions of its developer community, and, in particular,
David Heinemeier Hansson (DHH), its creator. Rails is particularly
opinionated towards the database systems that it tasks with data
storage. To quote DHH:
\begin{quote}
``I don't \textit{want} my database to be clever! \dots I consider stored procedures and constraints vile and reckless destroyers of coherence. No, Mr. Database, you can not have my business logic. Your procedural ambitions will bear no fruit and you'll have to pry that logic from my dead, cold object-oriented hands \dots I want a single layer of cleverness: My domain model.''~\cite{dhh-clever}
\end{quote}
Thus, this wildly successful software framework bears an actively
antagonistic relationship to database management systems, echoing a familiar refrain of the ``NoSQL'' movement: get the database out of the way and let the application do the work.

In this paper, we examine the implications of this decision---for
Rails as a framework, for applications built using Rails, and for
database systems---through the lens of data integrity. In particular,
by shunning decades of work on native database concurrency control
solutions, Rails has developed a set of primitives for handling
application integrity in the application tier---building, from the
underlying database system's perspective, a \textit{feral} concurrency
control system. We examine the design and, more importantly,
\textit{use} of these feral mechanisms and evaluate their effective
``cleverness'' in practice by analyzing them and experimentally
quantifying data integrity violations in practice. Our goal is to
understand how this growing class of applications currently interacts
(or, as the case may be, does not interact) with database systems and
how we, as a database systems community, we can positively engage with
these criticisms to better serve the needs of these developers.

We begin by surveying the state of Rails' application-tier concurrency
control primitives and examining their use in 67 open source
applications representing a variety of use cases from e-Commerce to
Customer Relationship Management and social networking. We find that,
overwhelmingly, these applications use Rails' built-in support for
declarative invariants---or \textit{validations}---to protect data
integrity (i.e., instead of transactions, which are over 38 times less
common by usage). We find over $9980$ uses of application-level
validations across the applications designed to ensure correctness
criteria including referential integrity, uniqueness, and adherence to
common data formats.

Given this corpus, we subsequently ask: are these feral validations
actually correct? Do they work in practice? Under concurrent
execution, Rails will execute validation checks in parallel, and any
validation logic that is susceptible to races may lead to data
corruption under default (and sometimes strongest, including some
``serializable'') database isolation levels. Accordingly, we apply
invariant confluence analysis~\cite{coord-avoid} and show that, in
fact, over $74.7\%$ of Rails validation usage by volume is actually
safe under concurrent execution. However, the remainder, which include
uniqueness violations under insertion and foreign key constraint
violations under deletion, are not. Therefore, we quantify the impact
of concurrency on data corruption for Rails uniqueness and foreign key
constraints under both worst-case analysis and via actual Rails
deployment. We demonstrate that, for pathological workloads,
validations reduce the severity of data corruption by orders of
magnitude but, nevertheless, still permit serious integrity violations.

Given these results, we return to our goal of improving the underlying
data management systems that power these applications and present
recommendations for the database research community. We survey several
additional web frameworks and demonstrate that many also provide a
notion of feral validations, suggesting an industry-wide trend. While
the success of Rails and its ilk are firm evidence of the continued
``impedance mismatch'' between object-oriented programming and the
relational model, we see considerable opportunity in adapting existing
database concurrency control to better serve these communities---via
both increased native support for declarative invariants and
server-side code execution as well as broader education about,
understanding of, and less prevalent default use of weak isolation
guarantees.

In summary, this paper makes the following contributions:
\begin{myitemize}
\item We analyze 67 open source Ruby on Rails applications to
  determine their use of both database-backed and feral concurrency
  control mechanisms. This provides a quantitative picture of how
  mainstream web developers interact with database systems, and, more
  specifically, concurrency control.

\item We study these applications' feral mechanisms potential for
  application integrity violations. We analytically and experimentally
  quantify the incidence and degree of inconsistency allowed by
  Rails's uniqueness and association validations.

\item We survey six additional frameworks for similarly unsafe
  validations. Based on these results and those above, we present a
  set of recommendations for database systems designers, including
  increased database support for application invariants while avoiding
  coordination and ensuring portability across database backends.
\end{myitemize}

In all, this paper is a pragmatic attempt to understand how a large
and growing class of database management system users---namely, web
developers---interacts with the databases that this community
builds. In doing so, we hope to raise awareness about prevalent and,
as we discuss, largely under-supported application programming
patterns and their implications for the integrity of real-world,
end-user database-backed applications. While our contribution here is
\textit{not} a new system for database concurrency control, our goal
is to \textit{inform} designers and architects of next-generation data
management systems and provide quantitative evidence of the practical
shortcomings and pitfalls in real-world database concurrency control
today. We view this work as an early example of the promising
opportunity in continued empirical analysis of open source
applications and software as written and deployed in the wild
(Section~\ref{sec:conclusion}).

The remainder of this paper proceeds as
follows. Section~\ref{sec:motivation} briefly provides background on
Rails MVC and deployment, while Section~\ref{sec:rails-cc} surveys
Rails's supported concurrency control
mechanisms. Section~\ref{sec:apps} presents analysis of mechanism
usage in open source applications as well as safety under weak
isolation.  Section~\ref{sec:evaluation} experimentally quantifies the
degree of inconsistency allowed by these mechanisms in a Rails
deployment. Section~\ref{sec:other-orms} describes support for feral
validations in additional frameworks, and
Section~\ref{sec:discussion} presents recommendations for better
supporting these framework demands. Section~\ref{sec:relatedwork}
presents related work and Section~\ref{sec:conclusion} concludes.
